package goroutine

/*
goroutine是go语言的并发体。在go语言里面能使用go关键字来实现并发。
go func()

1.1 概念介绍
并发

一个计算机（一个cpu）上能同时执行多项任务，让cpu在某段时间内进行分片，在某段很短时间内执行程序a，然后又迅速得切换到程序b去执行，让人们看起来就像是两个程序在同时进行，这就是并发。

进程

但是人们随之发现，cpu在切换程序的时候，如果不保存上一个程序的状态（也就是我们常说的context--上下文），直接切换下一个程序，就会丢失上一个程序的一系列状态，
于是引入了进程这个概念，用以划分好程序运行时所需要的资源。因此进程就是一个程序运行时候的所需要的基本资源单位（也可以说是程序运行的一个实体）。

并行

如果一个电脑有多个cpu，每个cpu都有进程在运行，这就是并行。

用户态与内核态

为了防止用户程序做出一些危险的指令，如关机，更改系统变量，修改别的进程数据，系统分为两种运行状态，用户态以及内核态，
用户态是我们的程序所在的状态，不能随便对内核的底层进行操作。如果我们需要使用内核的底层操作的时候，内核提供了一种调用内核的接口，我们调用这些接口也就是系统调用，在进行系统调用的时候，cpu会切换到内核态，才能执行内核的函数。

线程

人们又发现一个问题，cpu切换多个进程的时候，会花费不少的时间，因为切换进程需要切换到内核态，而每次调度需要内核态都需要读取用户态的数据，进程一旦多起来，cpu调度会消耗一大堆资源，因此引入了线程的概念，线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不会那么像进程切换那么耗费资源。

协程

但是线程还是需要内核去进行调度，切换起来也是需要把用户态的数据写入到内核态，也是需要耗费一定的计算机资源，那可以不可以将切换的调度改成我们自己控制的呢，答案是有的，协程就是把自己的调度算法交给程序（用户态）去进行管理，能以更小的资源去进行并发。

goruntine

goroutine就是一个协程例子，可以根据自身调度器进行调度，当某个gooutine调用了time.sleep方法或者channel，mutex阻塞时候，调度器会使其入睡，唤醒另一个goroutine，根本不需要进入到内核态。

*/
import (
  "fmt"
  "time"
  "sync"
)


// 并发例子
func Base() {
    go func(){
        fmt.Println("hello")
    }()

    go func(){
       fmt.Println("world")
    }()
    time.Sleep(1 * time.Second)
}

// 安全退出
/*
goroutine只有在自身所在函数运行完毕，或者主函数运行完毕才会打断，因而上面的例子需要等待一秒，不然未执行完的goroutine会直接被打断。 如果我们并发的线程数量多了之后，我们不可能在main里面设置一个精确睡眠时间来评估所有的goroutine已经运行完毕然后退出。
 这时候我们可以使用sync.WaitGroup来等待所有运行的goroutine运行结束后，再来退出main函数，
 主要原理是维护一个goroutine数量的计数器，每运行一个goroutine，计数器会加+1，运行结束后，计数器会-1，
 然后调用wait方法会一直阻塞，知道计数器为0，也就是当前运行的goroutine数量为0，实例如下：
*/

func SafeWait() {
    var wg sync.WaitGroup
    // 开20个协程
    for i := 0; i < 20; i++ {
        wg.Add(1)
        //  一定要通过指针传值，不然进程会进入死锁状态  WaitGroup对象不是一个引用类型 函数是传值 相当于复制一个副本
        go func(i int, wg *sync.WaitGroup) {
            // 运行完后计数器减1 一定要在单个协程中操作
            defer wg.Done()
            time.Sleep(1 * time.Second)
            fmt.Printf("goroutine %d is running\n", i)
        }(i, &wg)
    }
    // 等待计数器为0
    wg.Wait()
}


